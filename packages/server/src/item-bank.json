{
  "version": "1.0.0",
  "items": [
    {
      "id": "js-this-001",
      "topic": "js-this",
      "difficulty": "easy",
      "stem": "What will be logged to the console?",
      "code": "const obj = {\n  name: 'Alice',\n  greet() {\n    console.log(this.name);\n  }\n};\n\nobj.greet();",
      "options": [
        { "id": "A", "text": "Alice" },
        { "id": "B", "text": "undefined" },
        { "id": "C", "text": "An empty string" },
        { "id": "D", "text": "ReferenceError: name is not defined" }
      ],
      "correct": "A",
      "feedback": {
        "correct": "Correct! When a method is called on an object, `this` refers to that object.",
        "incorrect": "Not quite. When calling `obj.greet()`, the `this` inside `greet` refers to `obj`.",
        "explanation": "In JavaScript, when a function is called as a method of an object (using dot notation), `this` is bound to the object before the dot. Here, `obj.greet()` means `this` is `obj`, so `this.name` is 'Alice'."
      }
    },
    {
      "id": "js-this-002",
      "topic": "js-this",
      "difficulty": "medium",
      "stem": "What will be logged to the console?",
      "code": "const obj = {\n  name: 'Alice',\n  greet() {\n    console.log(this.name);\n  }\n};\n\nconst greet = obj.greet;\ngreet();",
      "options": [
        { "id": "A", "text": "Alice" },
        { "id": "B", "text": "undefined" },
        { "id": "C", "text": "TypeError: Cannot read property 'name' of undefined" },
        { "id": "D", "text": "An empty string" }
      ],
      "correct": "B",
      "feedback": {
        "correct": "Correct! When the method is assigned to a variable and called without context, `this` becomes the global object (or undefined in strict mode).",
        "incorrect": "Remember: `this` is determined by how a function is called, not where it's defined.",
        "explanation": "When you assign `obj.greet` to a variable, you're copying the function reference without the object context. Calling `greet()` without an object means `this` defaults to the global object (in non-strict mode) or `undefined` (in strict mode). Since `window.name` is typically an empty string or undefined, you get `undefined`."
      }
    },
    {
      "id": "js-this-003",
      "topic": "js-this",
      "difficulty": "hard",
      "stem": "What will be logged to the console?",
      "code": "const obj = {\n  name: 'Alice',\n  greet: () => {\n    console.log(this.name);\n  }\n};\n\nobj.greet();",
      "options": [
        { "id": "A", "text": "Alice" },
        { "id": "B", "text": "undefined" },
        { "id": "C", "text": "TypeError: this is undefined" },
        { "id": "D", "text": "The global window's name property (or empty string)" }
      ],
      "correct": "B",
      "feedback": {
        "correct": "Correct! Arrow functions don't have their own `this`—they inherit it from the enclosing lexical scope.",
        "incorrect": "Arrow functions behave differently from regular functions regarding `this`.",
        "explanation": "Arrow functions do not have their own `this` binding. Instead, they capture `this` from the surrounding lexical scope at the time they're created. Here, the arrow function is created in the global scope (or module scope), so `this` refers to the global object or `undefined` in strict mode/modules. The fact that it's a property of `obj` doesn't matter."
      }
    },
    {
      "id": "js-closures-001",
      "topic": "js-closures",
      "difficulty": "easy",
      "stem": "What will be logged to the console?",
      "code": "function outer() {\n  const x = 10;\n  function inner() {\n    console.log(x);\n  }\n  return inner;\n}\n\nconst fn = outer();\nfn();",
      "options": [
        { "id": "A", "text": "10" },
        { "id": "B", "text": "undefined" },
        { "id": "C", "text": "ReferenceError: x is not defined" },
        { "id": "D", "text": "null" }
      ],
      "correct": "A",
      "feedback": {
        "correct": "Correct! The inner function 'closes over' the variable x, retaining access even after outer() returns.",
        "incorrect": "Think about what the inner function can still 'see' after outer() has finished executing.",
        "explanation": "A closure is formed when a function is defined inside another function and references variables from the outer function's scope. Even after `outer()` returns, `inner` maintains a reference to `x` in its closure. This is fundamental to how JavaScript manages scope and memory."
      }
    },
    {
      "id": "js-closures-002",
      "topic": "js-closures",
      "difficulty": "medium",
      "stem": "What will be logged to the console?",
      "code": "for (var i = 0; i < 3; i++) {\n  setTimeout(() => console.log(i), 0);\n}",
      "options": [
        { "id": "A", "text": "0, 1, 2" },
        { "id": "B", "text": "3, 3, 3" },
        { "id": "C", "text": "undefined, undefined, undefined" },
        { "id": "D", "text": "0, 0, 0" }
      ],
      "correct": "B",
      "feedback": {
        "correct": "Correct! All three callbacks share the same `i` variable, which equals 3 after the loop completes.",
        "incorrect": "Remember that `var` has function scope, not block scope, and setTimeout callbacks run after the loop.",
        "explanation": "With `var`, there's only one `i` variable shared across all iterations. By the time the setTimeout callbacks execute (after the loop finishes), `i` has already been incremented to 3. This is the classic closure-in-a-loop gotcha. Using `let` instead of `var` would create a new `i` for each iteration."
      }
    },
    {
      "id": "js-closures-003",
      "topic": "js-closures",
      "difficulty": "hard",
      "stem": "What will be logged to the console?",
      "code": "function createCounter() {\n  let count = 0;\n  return {\n    increment: () => ++count,\n    getCount: () => count\n  };\n}\n\nconst counter1 = createCounter();\nconst counter2 = createCounter();\n\ncounter1.increment();\ncounter1.increment();\ncounter2.increment();\n\nconsole.log(counter1.getCount(), counter2.getCount());",
      "options": [
        { "id": "A", "text": "2 1" },
        { "id": "B", "text": "3 3" },
        { "id": "C", "text": "2 2" },
        { "id": "D", "text": "1 1" }
      ],
      "correct": "A",
      "feedback": {
        "correct": "Correct! Each call to createCounter() creates a new closure with its own private `count` variable.",
        "incorrect": "Consider: does each counter share the same `count`, or do they have separate ones?",
        "explanation": "Each call to `createCounter()` creates a new execution context with its own `count` variable. `counter1` and `counter2` each have their own private `count` in their respective closures. This is a common pattern for creating private state in JavaScript."
      }
    },
    {
      "id": "js-async-001",
      "topic": "js-async",
      "difficulty": "easy",
      "stem": "What will be logged to the console, and in what order?",
      "code": "console.log('A');\n\nPromise.resolve().then(() => console.log('B'));\n\nconsole.log('C');",
      "options": [
        { "id": "A", "text": "A, B, C" },
        { "id": "B", "text": "A, C, B" },
        { "id": "C", "text": "B, A, C" },
        { "id": "D", "text": "A, C (B is never logged)" }
      ],
      "correct": "B",
      "feedback": {
        "correct": "Correct! Promise callbacks are microtasks that run after the current synchronous code completes.",
        "incorrect": "Think about when Promise callbacks actually execute relative to synchronous code.",
        "explanation": "JavaScript executes synchronous code first, then processes microtasks (like Promise callbacks) before moving to the next macrotask. So 'A' logs first, then 'C', then the Promise callback runs and logs 'B'."
      }
    },
    {
      "id": "js-async-002",
      "topic": "js-async",
      "difficulty": "medium",
      "stem": "What will be logged to the console?",
      "code": "async function foo() {\n  console.log('1');\n  await Promise.resolve();\n  console.log('2');\n}\n\nconsole.log('3');\nfoo();\nconsole.log('4');",
      "options": [
        { "id": "A", "text": "3, 1, 4, 2" },
        { "id": "B", "text": "3, 1, 2, 4" },
        { "id": "C", "text": "1, 2, 3, 4" },
        { "id": "D", "text": "3, 4, 1, 2" }
      ],
      "correct": "A",
      "feedback": {
        "correct": "Correct! Code after `await` is scheduled as a microtask, while code before `await` runs synchronously.",
        "incorrect": "Remember: an async function runs synchronously until it hits the first `await`.",
        "explanation": "When `foo()` is called, it executes synchronously until the `await`. So '3' logs, then '1' logs (inside foo), then the await pauses foo and returns control. '4' logs, then the microtask queue processes and '2' logs. The key insight: everything before `await` is synchronous."
      }
    },
    {
      "id": "js-async-003",
      "topic": "js-async",
      "difficulty": "hard",
      "stem": "What will be logged to the console?",
      "code": "Promise.resolve()\n  .then(() => {\n    console.log('1');\n    return Promise.resolve();\n  })\n  .then(() => console.log('2'));\n\nPromise.resolve()\n  .then(() => console.log('3'))\n  .then(() => console.log('4'));",
      "options": [
        { "id": "A", "text": "1, 2, 3, 4" },
        { "id": "B", "text": "1, 3, 2, 4" },
        { "id": "C", "text": "1, 3, 4, 2" },
        { "id": "D", "text": "3, 1, 4, 2" }
      ],
      "correct": "C",
      "feedback": {
        "correct": "Correct! Returning a Promise from a then() adds an extra microtask tick before the next then() can run.",
        "incorrect": "The key is understanding how returning a Promise from then() affects the microtask queue.",
        "explanation": "When a then() callback returns a Promise, the next then() in the chain must wait for that Promise to resolve, which takes an extra microtask. So: '1' logs, '3' logs (both first thens complete). Then '4' logs (second chain continues), and finally '2' logs (the returned Promise resolved, allowing the first chain to continue)."
      }
    },
    {
      "id": "js-prototypes-001",
      "topic": "js-prototypes",
      "difficulty": "easy",
      "stem": "What will be logged to the console?",
      "code": "function Animal(name) {\n  this.name = name;\n}\n\nAnimal.prototype.speak = function() {\n  return `${this.name} makes a sound`;\n};\n\nconst dog = new Animal('Rex');\nconsole.log(dog.speak());",
      "options": [
        { "id": "A", "text": "Rex makes a sound" },
        { "id": "B", "text": "undefined makes a sound" },
        { "id": "C", "text": "TypeError: dog.speak is not a function" },
        { "id": "D", "text": "Animal makes a sound" }
      ],
      "correct": "A",
      "feedback": {
        "correct": "Correct! The `dog` instance inherits the `speak` method from Animal.prototype.",
        "incorrect": "Remember that methods on the prototype are inherited by all instances.",
        "explanation": "When you use `new Animal('Rex')`, JavaScript creates an object whose prototype is `Animal.prototype`. The `speak` method isn't on `dog` directly, but JavaScript finds it by following the prototype chain. When called, `this` refers to `dog`, so `this.name` is 'Rex'."
      }
    },
    {
      "id": "js-prototypes-002",
      "topic": "js-prototypes",
      "difficulty": "medium",
      "stem": "What will be logged to the console?",
      "code": "const obj = { a: 1 };\nconst child = Object.create(obj);\nchild.b = 2;\n\nconsole.log(child.a, child.hasOwnProperty('a'));",
      "options": [
        { "id": "A", "text": "1, true" },
        { "id": "B", "text": "1, false" },
        { "id": "C", "text": "undefined, false" },
        { "id": "D", "text": "1, TypeError" }
      ],
      "correct": "B",
      "feedback": {
        "correct": "Correct! `child` can access `a` through its prototype, but it's not its 'own' property.",
        "incorrect": "Think about the difference between inherited properties and own properties.",
        "explanation": "`Object.create(obj)` creates a new object with `obj` as its prototype. `child` can access `a` through the prototype chain, but `hasOwnProperty` only returns true for properties directly on the object itself, not inherited ones."
      }
    },
    {
      "id": "js-prototypes-003",
      "topic": "js-prototypes",
      "difficulty": "hard",
      "stem": "What will be logged to the console?",
      "code": "function Foo() {}\nFoo.prototype.x = 1;\n\nconst a = new Foo();\nconst b = new Foo();\n\na.x = 2;\nFoo.prototype.x = 3;\n\nconsole.log(a.x, b.x);",
      "options": [
        { "id": "A", "text": "2, 3" },
        { "id": "B", "text": "2, 1" },
        { "id": "C", "text": "3, 3" },
        { "id": "D", "text": "2, 2" }
      ],
      "correct": "A",
      "feedback": {
        "correct": "Correct! Setting `a.x = 2` creates an own property on `a`, shadowing the prototype. `b` still reads from the prototype.",
        "incorrect": "Consider what happens when you set a property on an instance vs. the prototype.",
        "explanation": "When you do `a.x = 2`, JavaScript creates a new 'own' property `x` on `a`, which shadows the prototype's `x`. Now `a.x` reads from the own property (2), ignoring the prototype. But `b` has no own `x` property, so it still reads from `Foo.prototype.x`, which is now 3."
      }
    },
    {
      "id": "js-timers-001",
      "topic": "js-timers",
      "difficulty": "easy",
      "stem": "What will be logged to the console, and in what order?",
      "code": "console.log('start');\n\nsetTimeout(() => console.log('timeout'), 0);\n\nconsole.log('end');",
      "options": [
        { "id": "A", "text": "start, timeout, end" },
        { "id": "B", "text": "start, end, timeout" },
        { "id": "C", "text": "timeout, start, end" },
        { "id": "D", "text": "start, end (timeout never fires)" }
      ],
      "correct": "B",
      "feedback": {
        "correct": "Correct! Even with a 0ms delay, setTimeout callbacks are placed in the task queue and run after the current script.",
        "incorrect": "Remember that setTimeout(fn, 0) doesn't mean 'run immediately'.",
        "explanation": "setTimeout schedules a callback to run after a minimum delay, but it goes into the macrotask queue. The current synchronous code must complete before any queued tasks run. So 'start' and 'end' log first, then the event loop picks up the timeout callback."
      }
    },
    {
      "id": "js-timers-002",
      "topic": "js-timers",
      "difficulty": "medium",
      "stem": "What will be logged to the console, and in what order?",
      "code": "console.log('1');\n\nsetTimeout(() => console.log('2'), 0);\n\nPromise.resolve().then(() => console.log('3'));\n\nconsole.log('4');",
      "options": [
        { "id": "A", "text": "1, 4, 2, 3" },
        { "id": "B", "text": "1, 4, 3, 2" },
        { "id": "C", "text": "1, 2, 3, 4" },
        { "id": "D", "text": "1, 3, 4, 2" }
      ],
      "correct": "B",
      "feedback": {
        "correct": "Correct! Microtasks (Promise callbacks) have priority over macrotasks (setTimeout).",
        "incorrect": "Remember the priority: synchronous code → microtasks → macrotasks.",
        "explanation": "JavaScript processes the call stack first ('1', '4'), then drains the microtask queue (Promise callback: '3'), and finally processes the macrotask queue (setTimeout: '2'). Microtasks always run before the next macrotask."
      }
    },
    {
      "id": "js-timers-003",
      "topic": "js-timers",
      "difficulty": "hard",
      "stem": "What will be logged to the console, and in what order?",
      "code": "setTimeout(() => console.log('1'), 0);\n\nPromise.resolve()\n  .then(() => {\n    console.log('2');\n    return Promise.resolve();\n  })\n  .then(() => console.log('3'));\n\nPromise.resolve().then(() => console.log('4'));\n\nconsole.log('5');",
      "options": [
        { "id": "A", "text": "5, 2, 4, 3, 1" },
        { "id": "B", "text": "5, 2, 3, 4, 1" },
        { "id": "C", "text": "5, 4, 2, 3, 1" },
        { "id": "D", "text": "5, 2, 4, 1, 3" }
      ],
      "correct": "A",
      "feedback": {
        "correct": "Correct! Microtasks are processed in order, but returning a Promise delays the next then() by one tick.",
        "incorrect": "Track each microtask carefully, especially when a then() returns a Promise.",
        "explanation": "After '5' logs synchronously, the microtask queue has two items: the first then() of each Promise chain. '2' logs, but returning Promise.resolve() delays '3'. '4' logs next. Then '3' logs (the returned Promise resolved). Finally, the macrotask '1' runs."
      }
    },
    {
      "id": "js-patterns-001",
      "topic": "js-patterns",
      "difficulty": "easy",
      "stem": "What will be logged to the console?",
      "code": "const user = { name: 'Alice', age: 30 };\nconst { name, role = 'user' } = user;\n\nconsole.log(name, role);",
      "options": [
        { "id": "A", "text": "Alice user" },
        { "id": "B", "text": "Alice undefined" },
        { "id": "C", "text": "undefined user" },
        { "id": "D", "text": "SyntaxError" }
      ],
      "correct": "A",
      "feedback": {
        "correct": "Correct! Default values in destructuring are used when the property is undefined or missing.",
        "incorrect": "Destructuring default values kick in when the value is undefined.",
        "explanation": "When destructuring, you can provide default values with `=`. Since `user.name` exists, `name` is 'Alice'. Since `user.role` is undefined (missing), the default value 'user' is used for `role`."
      }
    },
    {
      "id": "js-patterns-002",
      "topic": "js-patterns",
      "difficulty": "medium",
      "stem": "What will be logged to the console?",
      "code": "const arr = [1, 2, 3];\nconst [first, ...rest] = arr;\nconst newArr = [0, ...rest];\n\nconsole.log(newArr);",
      "options": [
        { "id": "A", "text": "[0, 1, 2, 3]" },
        { "id": "B", "text": "[0, 2, 3]" },
        { "id": "C", "text": "[0, [2, 3]]" },
        { "id": "D", "text": "[0, ...rest]" }
      ],
      "correct": "B",
      "feedback": {
        "correct": "Correct! Rest destructuring captures remaining elements, and spread expands them into the new array.",
        "incorrect": "Trace through each destructuring and spread operation step by step.",
        "explanation": "First, `[first, ...rest] = arr` assigns 1 to `first` and [2, 3] to `rest`. Then `[0, ...rest]` creates a new array by spreading `rest` (which is [2, 3]) into it after 0, resulting in [0, 2, 3]."
      }
    },
    {
      "id": "js-patterns-003",
      "topic": "js-patterns",
      "difficulty": "hard",
      "stem": "What will be logged to the console?",
      "code": "const obj = {\n  a: 1,\n  b: 2,\n  get sum() {\n    return this.a + this.b;\n  }\n};\n\nconst copy = { ...obj };\ncopy.a = 10;\n\nconsole.log(obj.sum, copy.sum);",
      "options": [
        { "id": "A", "text": "3 12" },
        { "id": "B", "text": "3 3" },
        { "id": "C", "text": "12 12" },
        { "id": "D", "text": "3 undefined" }
      ],
      "correct": "A",
      "feedback": {
        "correct": "Correct! Spread copies the getter's current value as a regular property, and each object's sum uses its own `this`.",
        "incorrect": "Consider what happens to getters when you spread an object.",
        "explanation": "When spreading an object, getters are invoked and their returned values are copied as plain data properties. So `copy.sum` is initially set to 3 (the result of obj.sum at copy time). Wait—actually, the spread does copy the getter as well! Each `sum` getter uses `this.a + this.b` where `this` refers to the object it's called on. So `obj.sum` is 1+2=3, and `copy.sum` is 10+2=12."
      }
    },
    {
      "id": "html-events-001",
      "topic": "html-events",
      "difficulty": "easy",
      "stem": "Given this HTML structure, which element's click handler runs first?",
      "code": "<div id=\"outer\">\n  <button id=\"inner\">Click me</button>\n</div>\n\n<script>\n  outer.addEventListener('click', () => console.log('outer'));\n  inner.addEventListener('click', () => console.log('inner'));\n</script>",
      "options": [
        { "id": "A", "text": "outer" },
        { "id": "B", "text": "inner" },
        { "id": "C", "text": "They run simultaneously" },
        { "id": "D", "text": "Only inner runs" }
      ],
      "correct": "B",
      "feedback": {
        "correct": "Correct! By default, events bubble from the target element outward.",
        "incorrect": "Think about the default event propagation direction in the DOM.",
        "explanation": "DOM events go through three phases: capture (outer to inner), target, and bubble (inner to outer). By default, addEventListener listens during the bubble phase. So when you click the button, 'inner' logs first, then the event bubbles up and 'outer' logs."
      }
    },
    {
      "id": "html-events-002",
      "topic": "html-events",
      "difficulty": "medium",
      "stem": "What will be logged when the button is clicked?",
      "code": "<div id=\"parent\">\n  <button id=\"child\">Click</button>\n</div>\n\n<script>\n  parent.addEventListener('click', () => console.log('parent'), true);\n  child.addEventListener('click', (e) => {\n    console.log('child');\n    e.stopPropagation();\n  });\n  parent.addEventListener('click', () => console.log('parent-bubble'));\n</script>",
      "options": [
        { "id": "A", "text": "child, parent-bubble" },
        { "id": "B", "text": "parent, child" },
        { "id": "C", "text": "parent, child, parent-bubble" },
        { "id": "D", "text": "child" }
      ],
      "correct": "B",
      "feedback": {
        "correct": "Correct! The capture listener runs first, then the target handler which stops propagation.",
        "incorrect": "The third parameter `true` enables capture mode. What order do capture vs bubble listeners fire?",
        "explanation": "The first parent listener uses capture mode (third parameter is `true`), so it fires during the capture phase before the event reaches the target. Then 'child' logs. `stopPropagation()` prevents the event from continuing, so 'parent-bubble' never fires."
      }
    },
    {
      "id": "html-events-003",
      "topic": "html-events",
      "difficulty": "hard",
      "stem": "Using event delegation, how would you efficiently handle clicks on dynamically added list items?",
      "code": "<ul id=\"list\">\n  <li>Item 1</li>\n  <li>Item 2</li>\n</ul>\n\n// Later: new <li> elements are added dynamically",
      "options": [
        { "id": "A", "text": "Attach a click handler to each <li> when it's created" },
        { "id": "B", "text": "Use list.addEventListener('click', handler) and check event.target" },
        { "id": "C", "text": "Use document.querySelectorAll('li').forEach(li => li.onclick = handler)" },
        { "id": "D", "text": "Use MutationObserver to detect new <li> elements and attach handlers" }
      ],
      "correct": "B",
      "feedback": {
        "correct": "Correct! Event delegation uses a single handler on a parent element, checking the event target.",
        "incorrect": "Event delegation leverages event bubbling for efficient handling of dynamic content.",
        "explanation": "Event delegation attaches one listener to a parent element that persists. When any child is clicked, the event bubbles up. You check `event.target` or `event.target.closest('li')` to determine which item was clicked. This works for existing and future elements, with better performance than individual handlers."
      }
    },
    {
      "id": "vibe-prompting-001",
      "topic": "vibe-prompting",
      "difficulty": "easy",
      "stem": "You want Claude to write a function that validates email addresses. Which prompt is most likely to produce high-quality, working code?",
      "options": [
        { "id": "A", "text": "Write email validation" },
        { "id": "B", "text": "Write a TypeScript function called validateEmail that takes a string and returns true if it's a valid email format, false otherwise. Include common edge cases like missing @ symbol." },
        { "id": "C", "text": "I need code for emails" },
        { "id": "D", "text": "Make something that checks if emails work" }
      ],
      "correct": "B",
      "feedback": {
        "correct": "Correct! Specific prompts with clear requirements (language, function name, inputs/outputs, edge cases) produce better results.",
        "incorrect": "Vague prompts lead to vague outputs. The AI can't read your mind—you need to specify what you want.",
        "explanation": "Effective prompts for code generation include: the programming language, function/class name, input types and parameters, expected output/return type, and important edge cases or requirements. Option B provides all of these, while the others are too vague to produce reliable results."
      }
    },
    {
      "id": "vibe-prompting-002",
      "topic": "vibe-prompting",
      "difficulty": "medium",
      "stem": "You're using Claude to help refactor a complex 500-line React component. What's the most effective approach?",
      "options": [
        { "id": "A", "text": "Paste the entire component and ask 'refactor this'" },
        { "id": "B", "text": "Ask Claude to rewrite the whole thing from scratch based on a description" },
        { "id": "C", "text": "Break it into smaller tasks: first extract hooks, then split into subcomponents, then optimize renders—one step at a time" },
        { "id": "D", "text": "Send the file multiple times until Claude gets it right" }
      ],
      "correct": "C",
      "feedback": {
        "correct": "Correct! Breaking large tasks into focused steps produces better results and lets you validate each change.",
        "incorrect": "Large, vague requests often produce incomplete or incorrect refactors. Incremental changes are easier to review.",
        "explanation": "Vibecoding works best when you decompose complex tasks. Each step should be focused enough that you can verify the output. 'Extract the useAuth logic into a custom hook' is verifiable; 'refactor everything' is not. This also helps if something goes wrong—you can backtrack one step instead of losing everything."
      }
    },
    {
      "id": "vibe-prompting-003",
      "topic": "vibe-prompting",
      "difficulty": "hard",
      "stem": "You've asked Claude to implement a caching layer and received working code. What prompt technique would help ensure the code handles edge cases you haven't thought of?",
      "options": [
        { "id": "A", "text": "Ask Claude: 'What edge cases or failure modes should this caching implementation handle that I haven't considered?'" },
        { "id": "B", "text": "Just ship it—Claude probably covered everything" },
        { "id": "C", "text": "Ask for the code again and compare the two versions" },
        { "id": "D", "text": "Add more comments to your prompt" }
      ],
      "correct": "A",
      "feedback": {
        "correct": "Correct! Asking the AI to critique its own output or identify gaps is a powerful technique for discovering blind spots.",
        "incorrect": "AI assistants can help you think more thoroughly—use them to challenge the code, not just generate it.",
        "explanation": "This technique is called 'adversarial prompting' or 'red-teaming your own code.' By asking Claude to think about what could go wrong (cache invalidation race conditions, memory limits, TTL handling, cold starts), you leverage the AI's broad knowledge to catch issues you might miss. It's like having a code reviewer who's seen thousands of caching implementations."
      }
    },
    {
      "id": "vibe-review-001",
      "topic": "vibe-review",
      "difficulty": "easy",
      "stem": "Claude generates this code for user authentication. What's the most critical issue to check first?",
      "code": "async function login(username, password) {\n  const user = await db.query(\n    `SELECT * FROM users WHERE username='${username}' AND password='${password}'`\n  );\n  return user;\n}",
      "options": [
        { "id": "A", "text": "The function should use arrow syntax" },
        { "id": "B", "text": "SQL injection vulnerability from string interpolation" },
        { "id": "C", "text": "Missing TypeScript types" },
        { "id": "D", "text": "Should use a different variable name" }
      ],
      "correct": "B",
      "feedback": {
        "correct": "Correct! SQL injection is a critical security vulnerability. AI-generated code should always be reviewed for security issues.",
        "incorrect": "Security vulnerabilities are the highest priority when reviewing any code, especially AI-generated code.",
        "explanation": "This code is vulnerable to SQL injection—an attacker could input `' OR '1'='1` as the password to bypass authentication. AI models sometimes generate patterns from training data that include insecure practices. Always check for: SQL injection, XSS, hardcoded secrets, insecure dependencies, and improper input validation."
      }
    },
    {
      "id": "vibe-review-002",
      "topic": "vibe-review",
      "difficulty": "medium",
      "stem": "You asked Claude to write a React hook for fetching user data. The code works in your tests, but what potential issue should you investigate?",
      "code": "function useUserData(userId) {\n  const [user, setUser] = useState(null);\n  \n  useEffect(() => {\n    fetch(`/api/users/${userId}`)\n      .then(res => res.json())\n      .then(data => setUser(data));\n  }, [userId]);\n  \n  return user;\n}",
      "options": [
        { "id": "A", "text": "The hook name should be capitalized" },
        { "id": "B", "text": "Race condition: if userId changes quickly, stale data might overwrite newer data" },
        { "id": "C", "text": "Should use class components instead" },
        { "id": "D", "text": "useState should come after useEffect" }
      ],
      "correct": "B",
      "feedback": {
        "correct": "Correct! Race conditions in async effects are a common bug that's easy to miss in basic testing.",
        "incorrect": "This code has a subtle bug that only appears with rapid userId changes—AI often misses these timing issues.",
        "explanation": "If userId changes from 1 to 2 quickly, both fetches run. If the fetch for user 1 returns after the fetch for user 2, you'll display user 1's data even though userId is 2. The fix: use an AbortController or a cleanup flag to ignore stale responses. AI-generated code often works for the 'happy path' but misses race conditions."
      }
    },
    {
      "id": "vibe-review-003",
      "topic": "vibe-review",
      "difficulty": "hard",
      "stem": "Claude generates a sorting algorithm that passes all your test cases. Before shipping, what verification step is MOST important for production code?",
      "options": [
        { "id": "A", "text": "Check if the code style matches your linter rules" },
        { "id": "B", "text": "Test with adversarial inputs: empty arrays, huge datasets, already-sorted data, all-duplicate values" },
        { "id": "C", "text": "Count the lines of code to ensure it's concise" },
        { "id": "D", "text": "Ask Claude if it thinks the code is correct" }
      ],
      "correct": "B",
      "feedback": {
        "correct": "Correct! Adversarial testing with edge cases catches bugs that 'normal' test cases miss.",
        "incorrect": "AI-generated code often handles typical cases well but fails on edge cases. Testing boundaries is essential.",
        "explanation": "AI-generated algorithms frequently fail on: empty inputs, single elements, maximum size inputs (performance), pre-sorted or reverse-sorted data, duplicate values, and boundary conditions. Your test suite should include these 'adversarial' cases. The AI wrote code that matches patterns from training data—it didn't reason about every edge case."
      }
    },
    {
      "id": "vibe-workflow-001",
      "topic": "vibe-workflow",
      "difficulty": "easy",
      "stem": "You're starting a new feature and want to use Claude effectively. What's the best first step?",
      "options": [
        { "id": "A", "text": "Ask Claude to write all the code immediately" },
        { "id": "B", "text": "Start by explaining the feature requirements and asking Claude to help you think through the architecture" },
        { "id": "C", "text": "Write all the code yourself first, then ask Claude to review it" },
        { "id": "D", "text": "Skip planning and iterate with Claude until something works" }
      ],
      "correct": "B",
      "feedback": {
        "correct": "Correct! Using AI for design and planning before coding leads to better architecture and fewer rewrites.",
        "incorrect": "AI assistants are valuable for thinking through problems, not just generating code.",
        "explanation": "Vibecoding isn't just 'AI writes code.' The most effective workflow uses AI at every stage: requirements clarification, architecture design, implementation, testing, and code review. Starting with planning helps catch issues early. 'Help me think through how to structure a real-time notification system' often saves hours compared to jumping straight to code."
      }
    },
    {
      "id": "vibe-workflow-002",
      "topic": "vibe-workflow",
      "difficulty": "medium",
      "stem": "You're debugging a tricky issue where API calls work locally but fail in production. How can Claude best help?",
      "options": [
        { "id": "A", "text": "Paste your entire codebase and ask 'why doesn't this work?'" },
        { "id": "B", "text": "Share the specific error message, relevant code, environment differences, and what you've already tried" },
        { "id": "C", "text": "Ask Claude to rewrite all your API code from scratch" },
        { "id": "D", "text": "Keep asking 'is this the bug?' for random lines of code" }
      ],
      "correct": "B",
      "feedback": {
        "correct": "Correct! Structured debugging context helps Claude provide targeted, useful suggestions.",
        "incorrect": "Vague debugging requests get vague answers. Give Claude the context it needs to help you.",
        "explanation": "Effective debugging with AI requires: 1) The exact error message or unexpected behavior, 2) Relevant code snippets (not the whole codebase), 3) Environment context (local vs prod differences), 4) What you've already tried. This mirrors how you'd ask a senior developer for help—context makes the difference between 'have you checked CORS?' and an actual solution."
      }
    },
    {
      "id": "vibe-workflow-003",
      "topic": "vibe-workflow",
      "difficulty": "hard",
      "stem": "Your team wants to adopt AI coding assistants. What practice is MOST important to establish?",
      "options": [
        { "id": "A", "text": "Ban AI for 'important' code and only use it for boilerplate" },
        { "id": "B", "text": "Let each developer use AI however they want with no guidelines" },
        { "id": "C", "text": "Establish that AI-generated code gets the same review rigor as human code, plus explicit checks for common AI failure modes" },
        { "id": "D", "text": "Require AI attribution in code comments for legal reasons" }
      ],
      "correct": "C",
      "feedback": {
        "correct": "Correct! AI-generated code should meet all normal quality standards, with additional attention to AI-specific pitfalls.",
        "incorrect": "The source of code (human or AI) matters less than whether it's correct, secure, and maintainable.",
        "explanation": "Teams that succeed with AI assistants treat AI output as a starting point, not a finished product. Code review should check for: security vulnerabilities (AI training data includes vulnerable patterns), hallucinated APIs or dependencies, subtle logic errors in edge cases, and violations of team conventions. The code review process stays the same—you're reviewing code, not validating the AI."
      }
    },
    {
      "id": "react-hooks-001",
      "topic": "react-hooks",
      "difficulty": "easy",
      "stem": "What will be displayed after clicking the button once?",
      "code": "function Counter() {\n  const [count, setCount] = useState(0);\n  \n  const handleClick = () => {\n    setCount(count + 1);\n    setCount(count + 1);\n  };\n  \n  return <button onClick={handleClick}>{count}</button>;\n}",
      "options": [
        { "id": "A", "text": "0" },
        { "id": "B", "text": "1" },
        { "id": "C", "text": "2" },
        { "id": "D", "text": "Error: can't call setCount twice" }
      ],
      "correct": "B",
      "feedback": {
        "correct": "Correct! Both setCount calls use the same stale `count` value (0), so both set it to 1.",
        "incorrect": "State updates using the current value are batched—both calls see the same `count`.",
        "explanation": "React batches state updates for performance. Both `setCount(count + 1)` calls happen in the same render, so both read `count` as 0 and try to set it to 1. To increment twice, use the functional form: `setCount(prev => prev + 1)` which always uses the latest state."
      }
    },
    {
      "id": "react-hooks-002",
      "topic": "react-hooks",
      "difficulty": "medium",
      "stem": "What happens when this component mounts?",
      "code": "function DataFetcher() {\n  const [data, setData] = useState(null);\n  \n  useEffect(() => {\n    fetch('/api/data')\n      .then(res => res.json())\n      .then(setData);\n  });\n  \n  return <div>{data?.name}</div>;\n}",
      "options": [
        { "id": "A", "text": "Fetches data once when the component mounts" },
        { "id": "B", "text": "Infinite loop: fetch → setData → re-render → fetch..." },
        { "id": "C", "text": "Error: useEffect requires a dependency array" },
        { "id": "D", "text": "Nothing happens because data starts as null" }
      ],
      "correct": "B",
      "feedback": {
        "correct": "Correct! Without a dependency array, useEffect runs after every render, creating an infinite loop.",
        "incorrect": "useEffect with no dependency array runs on every render—what happens when setData triggers a re-render?",
        "explanation": "Without a dependency array, useEffect runs after every render. When setData updates state, the component re-renders, which runs useEffect again, which fetches again, which calls setData again... Add `[]` as the second argument to run only on mount, or `[someValue]` to run when someValue changes."
      }
    },
    {
      "id": "react-hooks-003",
      "topic": "react-hooks",
      "difficulty": "hard",
      "stem": "Why might this custom hook cause problems?",
      "code": "function useDebounce(value, delay) {\n  const [debouncedValue, setDebouncedValue] = useState(value);\n  \n  useEffect(() => {\n    const timer = setTimeout(() => {\n      setDebouncedValue(value);\n    }, delay);\n    \n    return () => clearTimeout(timer);\n  }, [value]);\n  \n  return debouncedValue;\n}",
      "options": [
        { "id": "A", "text": "Missing `delay` in the dependency array—changing delay won't restart the timer" },
        { "id": "B", "text": "Should use useRef instead of useState" },
        { "id": "C", "text": "The cleanup function is unnecessary" },
        { "id": "D", "text": "This hook is implemented correctly" }
      ],
      "correct": "A",
      "feedback": {
        "correct": "Correct! If `delay` changes, the effect won't re-run because it's not in the dependency array.",
        "incorrect": "Check what the effect depends on—all values from the component scope should be in the array.",
        "explanation": "The effect uses both `value` and `delay` from outside the effect. If `delay` changes (say, from 300ms to 1000ms), the effect won't re-run because `delay` isn't in the dependency array. This is a lint warning (exhaustive-deps rule) and a real bug. The fix: `[value, delay]`."
      }
    },
    {
      "id": "react-state-001",
      "topic": "react-state",
      "difficulty": "easy",
      "stem": "What's wrong with this state update?",
      "code": "function TodoList() {\n  const [todos, setTodos] = useState([{ id: 1, text: 'Learn React' }]);\n  \n  const addTodo = (text) => {\n    todos.push({ id: Date.now(), text });\n    setTodos(todos);\n  };\n  \n  return /* render todos */;\n}",
      "options": [
        { "id": "A", "text": "Should use useReducer instead of useState" },
        { "id": "B", "text": "Mutating state directly—push modifies the original array, then setTodos receives the same reference" },
        { "id": "C", "text": "Date.now() is not a valid ID" },
        { "id": "D", "text": "Missing key prop in the render" }
      ],
      "correct": "B",
      "feedback": {
        "correct": "Correct! React compares object references. Mutating and passing the same array won't trigger a re-render.",
        "incorrect": "React needs a new array reference to detect changes. What does `push` return?",
        "explanation": "Never mutate state directly! `todos.push()` modifies the existing array, then `setTodos(todos)` passes the same reference. React sees the same object reference and may skip re-rendering. Instead: `setTodos([...todos, { id: Date.now(), text }])` or `setTodos(prev => [...prev, newTodo])`."
      }
    },
    {
      "id": "react-state-002",
      "topic": "react-state",
      "difficulty": "medium",
      "stem": "What value does `name` have when the alert shows?",
      "code": "function Form() {\n  const [name, setName] = useState('Alice');\n  \n  const handleClick = () => {\n    setName('Bob');\n    alert(name);\n  };\n  \n  return <button onClick={handleClick}>Show Name</button>;\n}",
      "options": [
        { "id": "A", "text": "Bob" },
        { "id": "B", "text": "Alice" },
        { "id": "C", "text": "undefined" },
        { "id": "D", "text": "Error: name is not defined" }
      ],
      "correct": "B",
      "feedback": {
        "correct": "Correct! State updates are asynchronous. The alert uses the `name` value from this render, not the next one.",
        "incorrect": "setName schedules an update for the next render. What value does `name` have right now?",
        "explanation": "React state updates are asynchronous—`setName('Bob')` schedules a re-render with the new value, but doesn't change `name` in the current execution. The `name` variable in this closure still holds 'Alice'. To see the new value, you'd need to wait for the re-render or use `useEffect`."
      }
    },
    {
      "id": "react-state-003",
      "topic": "react-state",
      "difficulty": "hard",
      "stem": "This component has a bug when rapidly clicking 'Increment'. What's the issue?",
      "code": "function AsyncCounter() {\n  const [count, setCount] = useState(0);\n  \n  const increment = async () => {\n    await fetch('/api/log-click');\n    setCount(count + 1);\n  };\n  \n  return <button onClick={increment}>{count}</button>;\n}",
      "options": [
        { "id": "A", "text": "async/await can't be used in React event handlers" },
        { "id": "B", "text": "Stale closure: if clicked 3x quickly, all 3 calls use count=0, resulting in count=1" },
        { "id": "C", "text": "fetch() is not allowed in onClick handlers" },
        { "id": "D", "text": "Missing error handling for the fetch" }
      ],
      "correct": "B",
      "feedback": {
        "correct": "Correct! Each click captures `count` from its render. After await, they all try to set count to the same value.",
        "incorrect": "What value does `count` have when each async function resumes after the await?",
        "explanation": "Each click creates a closure that captures `count` at click time. If you click 3 times before any fetch completes, all 3 closures have `count = 0`. When they resume and call `setCount(count + 1)`, they all set it to 1. Fix: use functional update `setCount(c => c + 1)` which always uses the latest state."
      }
    },
    {
      "id": "react-rendering-001",
      "topic": "react-rendering",
      "difficulty": "easy",
      "stem": "Why does this list have a React warning in the console?",
      "code": "function UserList({ users }) {\n  return (\n    <ul>\n      {users.map(user => (\n        <li>{user.name}</li>\n      ))}\n    </ul>\n  );\n}",
      "options": [
        { "id": "A", "text": "Should use forEach instead of map" },
        { "id": "B", "text": "Missing `key` prop on the <li> elements" },
        { "id": "C", "text": "Can't use curly braces inside JSX" },
        { "id": "D", "text": "user.name might be undefined" }
      ],
      "correct": "B",
      "feedback": {
        "correct": "Correct! React needs keys to efficiently update lists. Each item needs a unique, stable key.",
        "incorrect": "React gives a specific warning about lists. What does it say is missing?",
        "explanation": "When rendering arrays, React needs a `key` prop to identify which items changed, were added, or removed. Without keys, React has to re-render all items. Fix: `<li key={user.id}>{user.name}</li>`. Use stable IDs, not array indices (unless the list never reorders)."
      }
    },
    {
      "id": "react-rendering-002",
      "topic": "react-rendering",
      "difficulty": "medium",
      "stem": "When does the Child component re-render?",
      "code": "function Parent() {\n  const [count, setCount] = useState(0);\n  const [name, setName] = useState('Alice');\n  \n  return (\n    <div>\n      <button onClick={() => setCount(c => c + 1)}>\n        Count: {count}\n      </button>\n      <Child name={name} />\n    </div>\n  );\n}\n\nfunction Child({ name }) {\n  console.log('Child rendered');\n  return <span>{name}</span>;\n}",
      "options": [
        { "id": "A", "text": "Only when `name` changes" },
        { "id": "B", "text": "Every time the button is clicked (when Parent re-renders)" },
        { "id": "C", "text": "Never, because name never changes" },
        { "id": "D", "text": "Only on initial mount" }
      ],
      "correct": "B",
      "feedback": {
        "correct": "Correct! By default, when Parent re-renders, all its children re-render too—even if their props didn't change.",
        "incorrect": "React re-renders children when their parent re-renders, regardless of prop changes.",
        "explanation": "React's default behavior is to re-render all children when a parent re-renders. Even though `name` doesn't change when clicking the button, Child still re-renders. To prevent this, wrap Child in `React.memo()`: `const Child = React.memo(({ name }) => ...)`. Then it only re-renders when `name` actually changes."
      }
    },
    {
      "id": "react-rendering-003",
      "topic": "react-rendering",
      "difficulty": "hard",
      "stem": "Even with React.memo, this Child re-renders on every Parent render. Why?",
      "code": "function Parent() {\n  const [count, setCount] = useState(0);\n  \n  const config = { theme: 'dark' };\n  \n  return (\n    <div>\n      <button onClick={() => setCount(c => c + 1)}>{count}</button>\n      <Child config={config} />\n    </div>\n  );\n}\n\nconst Child = React.memo(({ config }) => {\n  console.log('Child rendered');\n  return <div>{config.theme}</div>;\n});",
      "options": [
        { "id": "A", "text": "React.memo doesn't work with object props" },
        { "id": "B", "text": "`config` is a new object reference on every render, failing memo's shallow comparison" },
        { "id": "C", "text": "memo() should be called differently" },
        { "id": "D", "text": "The Child component syntax is wrong" }
      ],
      "correct": "B",
      "feedback": {
        "correct": "Correct! `{ theme: 'dark' }` creates a new object every render. memo compares by reference, not by value.",
        "incorrect": "React.memo does a shallow comparison. What does that mean for object props?",
        "explanation": "Every time Parent renders, `const config = { theme: 'dark' }` creates a brand new object. Even though it has the same content, it's a different reference. React.memo's shallow comparison sees different references and re-renders. Fix: `const config = useMemo(() => ({ theme: 'dark' }), [])` to maintain referential equality."
      }
    },
    {
      "id": "react-patterns-001",
      "topic": "react-patterns",
      "difficulty": "easy",
      "stem": "What React pattern does this code demonstrate?",
      "code": "function Card({ children }) {\n  return (\n    <div className=\"card\">\n      <div className=\"card-body\">\n        {children}\n      </div>\n    </div>\n  );\n}\n\n// Usage:\n<Card>\n  <h2>Title</h2>\n  <p>Content goes here</p>\n</Card>",
      "options": [
        { "id": "A", "text": "Higher-Order Component (HOC)" },
        { "id": "B", "text": "Render Props" },
        { "id": "C", "text": "Composition using children prop" },
        { "id": "D", "text": "Controlled Component" }
      ],
      "correct": "C",
      "feedback": {
        "correct": "Correct! The `children` prop allows components to wrap other content, enabling composition.",
        "incorrect": "This pattern lets you pass JSX as content to a wrapper component.",
        "explanation": "Composition with `children` is React's preferred pattern for reusability. Instead of using inheritance, you compose components by nesting them. The Card component doesn't need to know what's inside—it just provides the wrapper structure. This is more flexible than creating CardWithTitle, CardWithContent, etc."
      }
    },
    {
      "id": "react-patterns-002",
      "topic": "react-patterns",
      "difficulty": "medium",
      "stem": "What pattern should you use to share an input's value between components without prop drilling?",
      "code": "// Need to share `searchTerm` between Header, Sidebar, and ProductList\n// These components are deeply nested and not direct parent-children",
      "options": [
        { "id": "A", "text": "Pass it through every intermediate component as props" },
        { "id": "B", "text": "Use React Context to provide the value at a common ancestor" },
        { "id": "C", "text": "Store it in localStorage and read from there" },
        { "id": "D", "text": "Use window.searchTerm as a global variable" }
      ],
      "correct": "B",
      "feedback": {
        "correct": "Correct! Context lets you share state across the tree without manually passing props at every level.",
        "incorrect": "Prop drilling becomes unmaintainable. React has a built-in solution for this.",
        "explanation": "React Context is designed for sharing state that many components need (themes, user data, search terms). Create a context with `createContext()`, wrap your tree with a Provider, and consume with `useContext()`. This avoids passing props through components that don't need them."
      }
    },
    {
      "id": "react-patterns-003",
      "topic": "react-patterns",
      "difficulty": "hard",
      "stem": "What's the benefit of this pattern over simply passing `isOpen` and `setIsOpen` as props?",
      "code": "function Modal({ children }) {\n  const [isOpen, setIsOpen] = useState(false);\n  \n  return children({\n    isOpen,\n    open: () => setIsOpen(true),\n    close: () => setIsOpen(false),\n    toggle: () => setIsOpen(o => !o)\n  });\n}\n\n// Usage:\n<Modal>\n  {({ isOpen, open, close }) => (\n    <>\n      <button onClick={open}>Open Modal</button>\n      {isOpen && <div className=\"modal\">Content <button onClick={close}>×</button></div>}\n    </>\n  )}\n</Modal>",
      "options": [
        { "id": "A", "text": "It's faster because it avoids re-renders" },
        { "id": "B", "text": "The Modal component owns its state—consumers get a clean API without managing state themselves" },
        { "id": "C", "text": "It prevents the modal from being closed accidentally" },
        { "id": "D", "text": "This pattern is outdated and shouldn't be used" }
      ],
      "correct": "B",
      "feedback": {
        "correct": "Correct! Render props let a component encapsulate logic while giving consumers full control over rendering.",
        "incorrect": "This pattern inverts control—the Modal manages state, but the consumer controls the UI.",
        "explanation": "This 'render props' pattern (passing a function as children) encapsulates the open/close logic inside Modal. Consumers don't need to create their own `useState`—they just use the provided API. The Modal could add features (animations, escape key handling) without changing the consumer's code. It's the 'inversion of control' pattern."
      }
    },
    {
      "id": "plasma-cells-001",
      "topic": "plasma-cells",
      "difficulty": "easy",
      "stem": "Plasma cells are the terminally differentiated form of which immune cell type?",
      "options": [
        { "id": "A", "text": "T lymphocytes" },
        { "id": "B", "text": "B lymphocytes" },
        { "id": "C", "text": "Natural killer cells" },
        { "id": "D", "text": "Macrophages" }
      ],
      "correct": "B",
      "feedback": {
        "correct": "Correct! Plasma cells are the antibody-secreting end stage of B cell differentiation.",
        "incorrect": "Think about which immune cells are responsible for producing antibodies.",
        "explanation": "B lymphocytes (B cells) differentiate into plasma cells upon activation by antigen. This is the terminal differentiation pathway—plasma cells are specialized antibody factories that have downregulated most B cell surface markers and dedicated their cellular machinery to immunoglobulin production and secretion."
      }
    },
    {
      "id": "plasma-cells-002",
      "topic": "plasma-cells",
      "difficulty": "easy",
      "stem": "What is the primary function of plasma cells?",
      "options": [
        { "id": "A", "text": "Phagocytosis of pathogens" },
        { "id": "B", "text": "Secretion of antibodies (immunoglobulins)" },
        { "id": "C", "text": "Presentation of antigens to T cells" },
        { "id": "D", "text": "Direct killing of virus-infected cells" }
      ],
      "correct": "B",
      "feedback": {
        "correct": "Correct! Plasma cells are professional antibody-secreting cells, producing thousands of antibody molecules per second.",
        "incorrect": "Plasma cells have one specialized job in the immune system.",
        "explanation": "Plasma cells are essentially antibody factories. A single plasma cell can secrete several thousand antibody molecules per second. They have an extensively developed endoplasmic reticulum and Golgi apparatus to support this massive protein synthesis and secretion. This is their sole function—they don't phagocytose, present antigen, or directly kill cells."
      }
    },
    {
      "id": "plasma-cells-003",
      "topic": "plasma-cells",
      "difficulty": "medium",
      "stem": "Which surface marker is characteristically expressed on plasma cells but NOT on naive B cells?",
      "options": [
        { "id": "A", "text": "CD19" },
        { "id": "B", "text": "CD20" },
        { "id": "C", "text": "CD138 (Syndecan-1)" },
        { "id": "D", "text": "Surface IgM" }
      ],
      "correct": "C",
      "feedback": {
        "correct": "Correct! CD138 (Syndecan-1) is the classic plasma cell marker, upregulated during terminal differentiation.",
        "incorrect": "Consider which markers are gained vs lost during B cell to plasma cell differentiation.",
        "explanation": "CD138 (Syndecan-1) is acquired during plasma cell differentiation and is the key marker used to identify plasma cells. In contrast, CD19 and CD20 are pan-B cell markers that are downregulated or lost on mature plasma cells. Surface immunoglobulin is also lost as plasma cells switch to secreting rather than displaying antibodies."
      }
    },
    {
      "id": "plasma-cells-004",
      "topic": "plasma-cells",
      "difficulty": "medium",
      "stem": "Where do long-lived plasma cells primarily reside after an immune response?",
      "options": [
        { "id": "A", "text": "Circulating in the bloodstream" },
        { "id": "B", "text": "Lymph node germinal centers" },
        { "id": "C", "text": "Bone marrow" },
        { "id": "D", "text": "Thymus" }
      ],
      "correct": "C",
      "feedback": {
        "correct": "Correct! The bone marrow provides survival niches for long-lived plasma cells, enabling years of antibody production.",
        "incorrect": "Long-lived plasma cells migrate to a specific anatomical location that supports their survival.",
        "explanation": "After differentiation in secondary lymphoid organs, long-lived plasma cells migrate to the bone marrow where they can survive for years or even decades. The bone marrow provides specialized survival niches with stromal cells that produce factors like IL-6, APRIL, and CXCL12. These cells continuously secrete antibodies, providing long-term humoral immunity without requiring re-exposure to antigen."
      }
    },
    {
      "id": "plasma-cells-005",
      "topic": "plasma-cells",
      "difficulty": "medium",
      "stem": "Which transcription factor is essential for plasma cell differentiation and is often called the 'master regulator' of plasma cell development?",
      "options": [
        { "id": "A", "text": "PAX5" },
        { "id": "B", "text": "BLIMP-1 (PRDM1)" },
        { "id": "C", "text": "BCL-6" },
        { "id": "D", "text": "IRF4 alone" }
      ],
      "correct": "B",
      "feedback": {
        "correct": "Correct! BLIMP-1 (encoded by PRDM1) is the master transcription factor that drives plasma cell differentiation.",
        "incorrect": "One transcription factor acts as the key switch that commits B cells to become plasma cells.",
        "explanation": "BLIMP-1 (B lymphocyte-induced maturation protein 1) is essential for plasma cell differentiation. It represses genes required for B cell identity (including PAX5 and BCL-6) while activating the plasma cell program. PAX5 maintains B cell identity, BCL-6 is important for germinal center B cells, and while IRF4 cooperates with BLIMP-1, BLIMP-1 is considered the master regulator."
      }
    },
    {
      "id": "plasma-cells-006",
      "topic": "plasma-cells",
      "difficulty": "hard",
      "stem": "A patient has a monoclonal plasma cell proliferation. Which finding would suggest multiple myeloma rather than monoclonal gammopathy of undetermined significance (MGUS)?",
      "options": [
        { "id": "A", "text": "Presence of serum M-protein" },
        { "id": "B", "text": "Bone marrow plasma cells comprising 5% of cellularity" },
        { "id": "C", "text": "Lytic bone lesions on imaging" },
        { "id": "D", "text": "Age over 50 years" }
      ],
      "correct": "C",
      "feedback": {
        "correct": "Correct! End-organ damage (CRAB criteria: hyperCalcemia, Renal insufficiency, Anemia, Bone lesions) distinguishes myeloma from MGUS.",
        "incorrect": "The key distinction between MGUS and myeloma is the presence of end-organ damage.",
        "explanation": "Both MGUS and multiple myeloma have clonal plasma cells and M-protein. The critical difference is end-organ damage—the CRAB criteria. Lytic bone lesions indicate the malignant plasma cells are causing tissue destruction. MGUS by definition has <10% bone marrow plasma cells, M-protein <3 g/dL, and NO end-organ damage. When damage occurs, it's myeloma."
      }
    },
    {
      "id": "plasma-cells-007",
      "topic": "plasma-cells",
      "difficulty": "hard",
      "stem": "During class switch recombination in activated B cells (which later become plasma cells), which enzyme introduces DNA double-strand breaks at switch regions?",
      "options": [
        { "id": "A", "text": "RAG1/RAG2 recombinase" },
        { "id": "B", "text": "Activation-induced cytidine deaminase (AID)" },
        { "id": "C", "text": "Terminal deoxynucleotidyl transferase (TdT)" },
        { "id": "D", "text": "DNA-dependent protein kinase (DNA-PK)" }
      ],
      "correct": "B",
      "feedback": {
        "correct": "Correct! AID initiates class switch recombination by deaminating cytosines in switch region DNA, leading to double-strand breaks.",
        "incorrect": "Think about which enzyme is uniquely active in germinal center B cells during affinity maturation.",
        "explanation": "AID (Activation-induced cytidine deaminase) is essential for both somatic hypermutation and class switch recombination. It deaminates cytosines to uracils in switch region DNA, which are then processed into double-strand breaks. RAG1/2 mediates V(D)J recombination in early B cell development, TdT adds N-nucleotides during V(D)J recombination, and DNA-PK helps repair the breaks but doesn't initiate them."
      }
    },
    {
      "id": "plasma-cells-008",
      "topic": "plasma-cells",
      "difficulty": "hard",
      "stem": "Which cytokine produced by T follicular helper (Tfh) cells is critical for promoting B cell differentiation into antibody-secreting plasma cells?",
      "options": [
        { "id": "A", "text": "IL-2" },
        { "id": "B", "text": "IL-21" },
        { "id": "C", "text": "IL-12" },
        { "id": "D", "text": "TNF-alpha" }
      ],
      "correct": "B",
      "feedback": {
        "correct": "Correct! IL-21 is the signature cytokine of Tfh cells and is crucial for plasma cell differentiation and antibody production.",
        "incorrect": "Tfh cells in germinal centers produce a specific cytokine that drives B cells toward plasma cell fate.",
        "explanation": "IL-21, produced primarily by T follicular helper cells, is critical for B cell differentiation into plasma cells. It promotes the expression of BLIMP-1 and enhances immunoglobulin secretion. IL-21 also supports germinal center reactions and memory B cell formation. IL-2 supports T cell proliferation, IL-12 drives Th1 responses, and TNF-alpha is a pro-inflammatory cytokine."
      }
    },
    {
      "id": "plasma-cells-009",
      "topic": "plasma-cells",
      "difficulty": "easy",
      "stem": "What distinguishes short-lived plasmablasts from long-lived plasma cells?",
      "options": [
        { "id": "A", "text": "Plasmablasts cannot secrete antibodies" },
        { "id": "B", "text": "Plasmablasts are still proliferating and haven't fully matured" },
        { "id": "C", "text": "Only long-lived plasma cells express CD138" },
        { "id": "D", "text": "Plasmablasts produce IgM while plasma cells produce IgG" }
      ],
      "correct": "B",
      "feedback": {
        "correct": "Correct! Plasmablasts are proliferating, partially differentiated cells; plasma cells are terminally differentiated and non-dividing.",
        "incorrect": "Think about the developmental stage and proliferative capacity of these cells.",
        "explanation": "Plasmablasts are an intermediate stage—they're actively dividing cells that secrete antibody but haven't fully committed to the plasma cell program. They retain some B cell markers and proliferative capacity. Mature plasma cells are terminally differentiated, non-dividing, and have completely downregulated B cell markers. Both can secrete antibodies of any isotype and express CD138."
      }
    },
    {
      "id": "ts-basics-001",
      "topic": "ts-basics",
      "difficulty": "easy",
      "stem": "What TypeScript type should you use for a variable that can be either a string or null?",
      "options": [
        { "id": "A", "text": "string" },
        { "id": "B", "text": "string | null" },
        { "id": "C", "text": "string?" },
        { "id": "D", "text": "Maybe<string>" }
      ],
      "correct": "B",
      "feedback": {
        "correct": "Correct! Union types with `|` allow a value to be one of several types.",
        "incorrect": "TypeScript uses union types to represent values that could be multiple types.",
        "explanation": "The union type `string | null` means the variable can hold either a string value or null. The `?` syntax is only used for optional properties/parameters (which become `T | undefined`), and `Maybe<T>` is not a built-in TypeScript type."
      }
    },
    {
      "id": "ts-basics-002",
      "topic": "ts-basics",
      "difficulty": "easy",
      "stem": "What does this TypeScript code output?",
      "code": "interface User {\n  name: string;\n  age?: number;\n}\n\nconst user: User = { name: 'Alice' };\nconsole.log(user.age);",
      "options": [
        { "id": "A", "text": "undefined" },
        { "id": "B", "text": "null" },
        { "id": "C", "text": "TypeError: age is not defined" },
        { "id": "D", "text": "Compilation error: age is required" }
      ],
      "correct": "A",
      "feedback": {
        "correct": "Correct! Optional properties (with ?) are undefined when not provided.",
        "incorrect": "The `?` makes a property optional—what value does an unset property have?",
        "explanation": "The `?` in `age?: number` makes the property optional. When a property isn't provided, accessing it returns `undefined`. This compiles fine because TypeScript knows `age` is `number | undefined`. At runtime, JavaScript returns `undefined` for missing properties."
      }
    },
    {
      "id": "ts-basics-003",
      "topic": "ts-basics",
      "difficulty": "medium",
      "stem": "What's the TypeScript error in this code?",
      "code": "function greet(name: string): string {\n  if (name) {\n    return `Hello, ${name}!`;\n  }\n}",
      "options": [
        { "id": "A", "text": "No error—this compiles fine" },
        { "id": "B", "text": "Function lacks ending return statement and return type does not include 'undefined'" },
        { "id": "C", "text": "Cannot use template literals in TypeScript" },
        { "id": "D", "text": "The if condition is invalid" }
      ],
      "correct": "B",
      "feedback": {
        "correct": "Correct! Not all code paths return a value, but the return type promises `string`.",
        "incorrect": "What happens if `name` is an empty string?",
        "explanation": "If `name` is falsy (empty string), the function returns `undefined` implicitly. But the return type is `string`, not `string | undefined`. TypeScript catches this: 'Function lacks ending return statement and return type does not include undefined.' Fix: add `return ''` at the end, or change return type to `string | undefined`."
      }
    },
    {
      "id": "ts-generics-001",
      "topic": "ts-generics",
      "difficulty": "medium",
      "stem": "What type does `result` have?",
      "code": "function identity<T>(arg: T): T {\n  return arg;\n}\n\nconst result = identity('hello');",
      "options": [
        { "id": "A", "text": "T" },
        { "id": "B", "text": "string" },
        { "id": "C", "text": "any" },
        { "id": "D", "text": "unknown" }
      ],
      "correct": "B",
      "feedback": {
        "correct": "Correct! TypeScript infers the generic type from the argument.",
        "incorrect": "Generics are resolved at compile time based on usage.",
        "explanation": "When you call `identity('hello')`, TypeScript infers that `T` is `string` because the argument is a string. So the return type is also `string`. You could explicitly write `identity<string>('hello')`, but TypeScript's inference handles it automatically."
      }
    },
    {
      "id": "ts-generics-002",
      "topic": "ts-generics",
      "difficulty": "hard",
      "stem": "What does this utility type do?",
      "code": "type Readonly<T> = {\n  readonly [P in keyof T]: T[P];\n};",
      "options": [
        { "id": "A", "text": "Makes all properties of T optional" },
        { "id": "B", "text": "Makes all properties of T immutable (read-only)" },
        { "id": "C", "text": "Extracts only the string keys from T" },
        { "id": "D", "text": "Creates a union of all property types in T" }
      ],
      "correct": "B",
      "feedback": {
        "correct": "Correct! This mapped type adds `readonly` to every property of T.",
        "incorrect": "Look at what modifier is being applied to each property.",
        "explanation": "`[P in keyof T]` iterates over all keys of T. For each key P, we create a property with the same name and type (`T[P]`), but add `readonly`. This is actually a built-in TypeScript utility type. `Readonly<{name: string}>` becomes `{readonly name: string}`."
      }
    },
    {
      "id": "ts-generics-003",
      "topic": "ts-generics",
      "difficulty": "hard",
      "stem": "What's the inferred type of `value`?",
      "code": "function getValue<T, K extends keyof T>(obj: T, key: K): T[K] {\n  return obj[key];\n}\n\nconst user = { name: 'Alice', age: 30 };\nconst value = getValue(user, 'age');",
      "options": [
        { "id": "A", "text": "string | number" },
        { "id": "B", "text": "number" },
        { "id": "C", "text": "any" },
        { "id": "D", "text": "'age'" }
      ],
      "correct": "B",
      "feedback": {
        "correct": "Correct! TypeScript knows that `user['age']` is specifically a number.",
        "incorrect": "The generic constraint `K extends keyof T` enables precise type inference.",
        "explanation": "This is the type-safe way to access object properties. `K extends keyof T` means K must be a key of T. When called with `'age'`, K is the literal type `'age'`, and `T[K]` (which is `typeof user['age']`) is `number`. This pattern is used in libraries like lodash's `get` function."
      }
    },
    {
      "id": "css-tailwind-001",
      "topic": "css-tailwind",
      "difficulty": "easy",
      "stem": "In Tailwind CSS, what does the class `flex items-center justify-between` create?",
      "options": [
        { "id": "A", "text": "A grid with centered items" },
        { "id": "B", "text": "A flexbox with vertically centered items spread horizontally" },
        { "id": "C", "text": "A block element with text alignment" },
        { "id": "D", "text": "An inline element with padding" }
      ],
      "correct": "B",
      "feedback": {
        "correct": "Correct! `flex` enables flexbox, `items-center` centers vertically, `justify-between` spreads items horizontally.",
        "incorrect": "Break down each class: flex, items-center, justify-between.",
        "explanation": "`flex` sets `display: flex`. `items-center` sets `align-items: center` (vertical centering in row direction). `justify-between` sets `justify-content: space-between` (first item at start, last at end, equal space between). This is a common pattern for headers and navbars."
      }
    },
    {
      "id": "css-tailwind-002",
      "topic": "css-tailwind",
      "difficulty": "medium",
      "stem": "What does `hover:bg-blue-500` do in Tailwind CSS?",
      "options": [
        { "id": "A", "text": "Always applies a blue background" },
        { "id": "B", "text": "Applies blue background only on hover state" },
        { "id": "C", "text": "Creates a hover animation to blue" },
        { "id": "D", "text": "Sets the hover cursor to a blue pointer" }
      ],
      "correct": "B",
      "feedback": {
        "correct": "Correct! The `hover:` prefix applies styles only when the element is hovered.",
        "incorrect": "Tailwind uses prefixes like `hover:` to apply styles conditionally.",
        "explanation": "Tailwind's state variants use prefixes. `hover:bg-blue-500` compiles to `.hover\\:bg-blue-500:hover { background-color: #3b82f6 }`. Other variants include `focus:`, `active:`, `disabled:`, `dark:` for dark mode, and responsive prefixes like `md:` and `lg:`."
      }
    },
    {
      "id": "css-tailwind-003",
      "topic": "css-tailwind",
      "difficulty": "medium",
      "stem": "What's the correct Tailwind class for responsive design that applies only on medium screens and up?",
      "options": [
        { "id": "A", "text": "@medium:hidden" },
        { "id": "B", "text": "md:hidden" },
        { "id": "C", "text": "medium-hidden" },
        { "id": "D", "text": "screen-md:hidden" }
      ],
      "correct": "B",
      "feedback": {
        "correct": "Correct! `md:` prefix applies styles at the medium breakpoint (768px) and above.",
        "incorrect": "Tailwind uses short prefixes for responsive breakpoints.",
        "explanation": "Tailwind's responsive prefixes are mobile-first: `sm:` (640px+), `md:` (768px+), `lg:` (1024px+), `xl:` (1280px+), `2xl:` (1536px+). `md:hidden` means 'hidden on medium screens and larger' while visible on smaller screens."
      }
    },
    {
      "id": "css-layout-001",
      "topic": "css-layout",
      "difficulty": "easy",
      "stem": "What CSS property creates a grid container?",
      "options": [
        { "id": "A", "text": "display: grid-container" },
        { "id": "B", "text": "display: grid" },
        { "id": "C", "text": "grid: true" },
        { "id": "D", "text": "layout: grid" }
      ],
      "correct": "B",
      "feedback": {
        "correct": "Correct! `display: grid` turns an element into a grid container.",
        "incorrect": "Grid layout is enabled through the display property.",
        "explanation": "`display: grid` creates a block-level grid container. Its children become grid items. You then define the grid structure with properties like `grid-template-columns`, `grid-template-rows`, and `gap`. There's also `display: inline-grid` for inline-level grid containers."
      }
    },
    {
      "id": "css-layout-002",
      "topic": "css-layout",
      "difficulty": "medium",
      "stem": "What does `grid-template-columns: repeat(3, 1fr)` create?",
      "options": [
        { "id": "A", "text": "3 columns of 1 pixel each" },
        { "id": "B", "text": "3 equal-width columns sharing available space" },
        { "id": "C", "text": "1 column repeated 3 times vertically" },
        { "id": "D", "text": "3 columns of 100% width each" }
      ],
      "correct": "B",
      "feedback": {
        "correct": "Correct! `repeat(3, 1fr)` creates 3 columns, each taking 1 fraction of available space.",
        "incorrect": "The `fr` unit represents a fraction of the available space.",
        "explanation": "`repeat(3, 1fr)` is shorthand for `1fr 1fr 1fr`. The `fr` unit distributes available space proportionally. Three `1fr` columns each get 1/3 of the container width. You could do `1fr 2fr 1fr` for a wider middle column. This is more flexible than percentages because it accounts for gaps."
      }
    },
    {
      "id": "css-layout-003",
      "topic": "css-layout",
      "difficulty": "hard",
      "stem": "Why might `position: sticky` not work as expected?",
      "options": [
        { "id": "A", "text": "It's not supported in modern browsers" },
        { "id": "B", "text": "A parent element has `overflow: hidden` or `overflow: auto`" },
        { "id": "C", "text": "The element needs `display: block`" },
        { "id": "D", "text": "Sticky only works on table headers" }
      ],
      "correct": "B",
      "feedback": {
        "correct": "Correct! Sticky positioning fails when any ancestor has an overflow value other than `visible`.",
        "incorrect": "There's a common CSS property on parent elements that breaks sticky.",
        "explanation": "A sticky element is positioned relative to its nearest scrolling ancestor. If a parent has `overflow: hidden`, `auto`, or `scroll`, the sticky element sticks to that container instead of the viewport—and if that container doesn't scroll, sticky appears broken. This is the most common 'sticky not working' issue."
      }
    },
    {
      "id": "node-api-001",
      "topic": "node-api",
      "difficulty": "easy",
      "stem": "In Express.js, how do you send a JSON response?",
      "code": "app.get('/api/user', (req, res) => {\n  const user = { name: 'Alice' };\n  // How to send user as JSON?\n});",
      "options": [
        { "id": "A", "text": "res.send(JSON.stringify(user))" },
        { "id": "B", "text": "res.json(user)" },
        { "id": "C", "text": "res.write(user)" },
        { "id": "D", "text": "return user" }
      ],
      "correct": "B",
      "feedback": {
        "correct": "Correct! `res.json()` serializes the object and sets the Content-Type header.",
        "incorrect": "Express has a dedicated method for JSON responses.",
        "explanation": "`res.json(user)` automatically stringifies the object, sets `Content-Type: application/json`, and sends the response. While `res.send(JSON.stringify(user))` works, `res.json()` is cleaner and handles edge cases like circular references better."
      }
    },
    {
      "id": "node-api-002",
      "topic": "node-api",
      "difficulty": "medium",
      "stem": "What's the purpose of middleware in Express?",
      "code": "app.use((req, res, next) => {\n  console.log('Request received');\n  next();\n});",
      "options": [
        { "id": "A", "text": "To define database schemas" },
        { "id": "B", "text": "To process requests before they reach route handlers" },
        { "id": "C", "text": "To compile TypeScript to JavaScript" },
        { "id": "D", "text": "To serve static HTML files" }
      ],
      "correct": "B",
      "feedback": {
        "correct": "Correct! Middleware functions execute in order before (or instead of) route handlers.",
        "incorrect": "Middleware sits between the incoming request and your route handlers.",
        "explanation": "Middleware functions have access to `req`, `res`, and `next`. They can modify the request/response, end the request cycle, or call `next()` to pass control to the next middleware. Common uses: logging, authentication, parsing request bodies, CORS headers, error handling."
      }
    },
    {
      "id": "node-api-003",
      "topic": "node-api",
      "difficulty": "medium",
      "stem": "What HTTP status code should you return for a successful POST that creates a resource?",
      "options": [
        { "id": "A", "text": "200 OK" },
        { "id": "B", "text": "201 Created" },
        { "id": "C", "text": "204 No Content" },
        { "id": "D", "text": "301 Moved Permanently" }
      ],
      "correct": "B",
      "feedback": {
        "correct": "Correct! 201 Created indicates a new resource was successfully created.",
        "incorrect": "Different success codes have specific semantic meanings.",
        "explanation": "201 Created is the appropriate response when a POST/PUT creates a new resource. 200 OK is for successful requests that don't create resources. 204 No Content is for success with no response body (like DELETE). Following HTTP semantics helps clients understand what happened."
      }
    },
    {
      "id": "node-async-001",
      "topic": "node-async",
      "difficulty": "hard",
      "stem": "What's wrong with this error handling?",
      "code": "app.get('/users', async (req, res) => {\n  const users = await db.getUsers();\n  res.json(users);\n});",
      "options": [
        { "id": "A", "text": "Nothing—async/await handles errors automatically" },
        { "id": "B", "text": "Unhandled promise rejection if db.getUsers() throws—Express won't catch async errors" },
        { "id": "C", "text": "Should use callbacks instead of async/await" },
        { "id": "D", "text": "res.json() can't be used with await" }
      ],
      "correct": "B",
      "feedback": {
        "correct": "Correct! Express 4.x doesn't catch errors from async route handlers automatically.",
        "incorrect": "Async/await changes how errors propagate in Express.",
        "explanation": "In Express 4.x, if an async route handler throws, it becomes an unhandled promise rejection—Express's error handler won't catch it. Fix: wrap in try/catch and call `next(error)`, use a wrapper function, or upgrade to Express 5.x which handles async errors. Libraries like `express-async-handler` help."
      }
    },
    {
      "id": "node-async-002",
      "topic": "node-async",
      "difficulty": "hard",
      "stem": "What's the benefit of using `Promise.all()` here instead of sequential awaits?",
      "code": "// Sequential\nconst users = await getUsers();\nconst posts = await getPosts();\nconst comments = await getComments();\n\n// Parallel\nconst [users, posts, comments] = await Promise.all([\n  getUsers(),\n  getPosts(),\n  getComments()\n]);",
      "options": [
        { "id": "A", "text": "No benefit—they're equivalent" },
        { "id": "B", "text": "Promise.all() runs all three concurrently, reducing total wait time" },
        { "id": "C", "text": "Promise.all() uses less memory" },
        { "id": "D", "text": "Promise.all() provides better error messages" }
      ],
      "correct": "B",
      "feedback": {
        "correct": "Correct! Independent async operations should run in parallel to minimize latency.",
        "incorrect": "Think about whether each operation depends on the previous one's result.",
        "explanation": "Sequential awaits wait for each promise before starting the next. If each takes 100ms, total time is 300ms. `Promise.all()` starts all three immediately—they run concurrently, so total time is ~100ms (the slowest one). Use this when operations are independent. Use sequential awaits when each depends on the previous result."
      }
    },
    {
      "id": "git-basics-001",
      "topic": "git-basics",
      "difficulty": "easy",
      "stem": "What does `git status` show?",
      "options": [
        { "id": "A", "text": "The commit history" },
        { "id": "B", "text": "Staged, unstaged, and untracked files" },
        { "id": "C", "text": "Remote repository URLs" },
        { "id": "D", "text": "Branch merge conflicts" }
      ],
      "correct": "B",
      "feedback": {
        "correct": "Correct! `git status` shows the state of your working directory and staging area.",
        "incorrect": "`git status` is for checking what's changed, not history.",
        "explanation": "`git status` shows: staged changes (ready to commit), unstaged changes (modified but not staged), untracked files (new files Git doesn't know about), and your current branch. It's the most common command for understanding your current state before committing."
      }
    },
    {
      "id": "git-basics-002",
      "topic": "git-basics",
      "difficulty": "easy",
      "stem": "What's the difference between `git pull` and `git fetch`?",
      "options": [
        { "id": "A", "text": "They're the same command" },
        { "id": "B", "text": "`fetch` downloads changes, `pull` downloads AND merges them" },
        { "id": "C", "text": "`pull` is for branches, `fetch` is for tags" },
        { "id": "D", "text": "`fetch` is faster because it skips validation" }
      ],
      "correct": "B",
      "feedback": {
        "correct": "Correct! `fetch` is safe—it downloads without modifying your working directory. `pull` = fetch + merge.",
        "incorrect": "One of these commands modifies your working directory, the other doesn't.",
        "explanation": "`git fetch` downloads commits, branches, and tags from remote but doesn't change your working directory. You can review changes before merging. `git pull` does `fetch` + `merge` (or `rebase` with `--rebase`), automatically integrating remote changes. `fetch` is safer; `pull` is more convenient."
      }
    },
    {
      "id": "git-branching-001",
      "topic": "git-branching",
      "difficulty": "medium",
      "stem": "You want to incorporate main branch updates into your feature branch. What's the cleanest approach?",
      "options": [
        { "id": "A", "text": "Delete feature branch and start over" },
        { "id": "B", "text": "`git rebase main` from your feature branch" },
        { "id": "C", "text": "`git push --force` to overwrite" },
        { "id": "D", "text": "Copy-paste the changes manually" }
      ],
      "correct": "B",
      "feedback": {
        "correct": "Correct! Rebasing replays your commits on top of main, creating a linear history.",
        "incorrect": "There's a Git command designed for incorporating upstream changes into a branch.",
        "explanation": "`git rebase main` (from your feature branch) takes your commits, temporarily removes them, updates to latest main, then replays your commits on top. This creates a clean, linear history. Alternative: `git merge main` creates a merge commit but preserves the branching history. Rebase for clean history; merge for accurate history."
      }
    },
    {
      "id": "git-branching-002",
      "topic": "git-branching",
      "difficulty": "hard",
      "stem": "You accidentally committed to main instead of a feature branch. How do you fix this?",
      "code": "# Current state: You're on main with an unwanted commit\n# Goal: Move the commit to a new feature branch",
      "options": [
        { "id": "A", "text": "`git reset --hard` to delete the commit permanently" },
        { "id": "B", "text": "Create branch from current state, then reset main: `git branch feature && git reset --hard HEAD~1`" },
        { "id": "C", "text": "`git revert HEAD` and commit again on the right branch" },
        { "id": "D", "text": "This can't be fixed—you must force push" }
      ],
      "correct": "B",
      "feedback": {
        "correct": "Correct! Create a branch to save the commit, then reset main to before the commit.",
        "incorrect": "You need to preserve the commit while removing it from main.",
        "explanation": "1) `git branch feature` creates a new branch pointing at current HEAD (including your commit). 2) `git reset --hard HEAD~1` moves main back one commit. Now `feature` has the commit and `main` is clean. Note: Only do this if you haven't pushed to remote. If pushed, use `revert` instead."
      }
    },
    {
      "id": "testing-basics-001",
      "topic": "testing-basics",
      "difficulty": "easy",
      "stem": "What type of test is this?",
      "code": "test('adds 1 + 2 to equal 3', () => {\n  expect(add(1, 2)).toBe(3);\n});",
      "options": [
        { "id": "A", "text": "Integration test" },
        { "id": "B", "text": "End-to-end test" },
        { "id": "C", "text": "Unit test" },
        { "id": "D", "text": "Smoke test" }
      ],
      "correct": "C",
      "feedback": {
        "correct": "Correct! Unit tests test individual functions or components in isolation.",
        "incorrect": "Consider the scope: what is being tested and how much of the system is involved?",
        "explanation": "Unit tests test a single 'unit' (function, method, component) in isolation, with no external dependencies. They're fast and specific. Integration tests test how units work together. E2E tests test the full application flow. This test checks one function with one input—classic unit test."
      }
    },
    {
      "id": "testing-basics-002",
      "topic": "testing-basics",
      "difficulty": "medium",
      "stem": "What's wrong with this test?",
      "code": "test('user signup works', async () => {\n  const user = await createUser('test@example.com');\n  expect(user.id).toBeDefined();\n  // Test ends here—user remains in database\n});",
      "options": [
        { "id": "A", "text": "Should use `it()` instead of `test()`" },
        { "id": "B", "text": "Missing cleanup—test data pollutes the database for other tests" },
        { "id": "C", "text": "async/await isn't supported in tests" },
        { "id": "D", "text": "toBeDefined() is not a valid matcher" }
      ],
      "correct": "B",
      "feedback": {
        "correct": "Correct! Tests should clean up after themselves to avoid affecting other tests.",
        "incorrect": "Consider what happens when you run this test multiple times or with other tests.",
        "explanation": "Tests should be isolated and repeatable. This test creates a user but never deletes it. Running tests multiple times accumulates data; tests may fail due to duplicate emails or hit row limits. Fix: use `afterEach` to clean up, use transactions that rollback, or use test databases that reset between runs."
      }
    },
    {
      "id": "testing-react-001",
      "topic": "testing-react",
      "difficulty": "medium",
      "stem": "What's the best way to query an element in React Testing Library?",
      "code": "<button data-testid=\"submit-btn\" className=\"btn-primary\">\n  Submit Form\n</button>",
      "options": [
        { "id": "A", "text": "getByClassName('btn-primary')" },
        { "id": "B", "text": "getByRole('button', { name: /submit form/i })" },
        { "id": "C", "text": "document.querySelector('.btn-primary')" },
        { "id": "D", "text": "getByTestId('submit-btn') is always best" }
      ],
      "correct": "B",
      "feedback": {
        "correct": "Correct! `getByRole` queries the accessibility tree, testing what users actually experience.",
        "incorrect": "React Testing Library prioritizes queries that reflect how users interact with your app.",
        "explanation": "RTL's query priority: getByRole > getByLabelText > getByPlaceholderText > getByText > getByDisplayValue > getByAltText > getByTitle > getByTestId. `getByRole` is preferred because it tests accessibility—if the query fails, your component may have accessibility issues. `data-testid` is a last resort."
      }
    },
    {
      "id": "testing-react-002",
      "topic": "testing-react",
      "difficulty": "hard",
      "stem": "Why is this test flaky?",
      "code": "test('shows loading then data', async () => {\n  render(<UserProfile userId=\"1\" />);\n  \n  expect(screen.getByText('Loading...')).toBeInTheDocument();\n  expect(screen.getByText('Alice')).toBeInTheDocument();\n});",
      "options": [
        { "id": "A", "text": "Can't have two expects in one test" },
        { "id": "B", "text": "Not waiting for async state update—'Alice' might not be rendered yet" },
        { "id": "C", "text": "Should use `findByText` instead of `getByText` for both" },
        { "id": "D", "text": "render() is synchronous so this always works" }
      ],
      "correct": "B",
      "feedback": {
        "correct": "Correct! `getByText` is synchronous and will fail if the element isn't immediately present.",
        "incorrect": "Consider the timing: when does 'Alice' appear in the DOM?",
        "explanation": "The component fetches data and shows 'Loading...' first, then 'Alice'. `getByText('Alice')` runs immediately after render, before the fetch completes—it fails. Fix: `await screen.findByText('Alice')` which waits up to 1 second for the element. Or use `waitFor()`. `findBy*` = `waitFor` + `getBy*`."
      }
    },
    {
      "id": "llm-prompting-001",
      "topic": "llm-prompting",
      "difficulty": "easy",
      "stem": "What is 'few-shot prompting'?",
      "options": [
        { "id": "A", "text": "Asking the LLM to respond in few words" },
        { "id": "B", "text": "Providing examples in the prompt to guide the model's output format" },
        { "id": "C", "text": "Making multiple API calls with short prompts" },
        { "id": "D", "text": "Limiting the number of tokens in the response" }
      ],
      "correct": "B",
      "feedback": {
        "correct": "Correct! Few-shot prompting includes examples to demonstrate the desired output pattern.",
        "incorrect": "'Few-shot' refers to the number of examples provided.",
        "explanation": "Few-shot prompting gives the model examples of input-output pairs before the actual task. 'Zero-shot' = no examples, 'one-shot' = one example, 'few-shot' = several examples. Examples help the model understand format, style, and reasoning pattern you want. It's one of the most effective prompting techniques."
      }
    },
    {
      "id": "llm-prompting-002",
      "topic": "llm-prompting",
      "difficulty": "medium",
      "stem": "What's the purpose of adding 'Think step by step' to a prompt?",
      "options": [
        { "id": "A", "text": "Makes responses shorter" },
        { "id": "B", "text": "Triggers chain-of-thought reasoning for better accuracy on complex tasks" },
        { "id": "C", "text": "Reduces API costs" },
        { "id": "D", "text": "Enables streaming responses" }
      ],
      "correct": "B",
      "feedback": {
        "correct": "Correct! Chain-of-thought prompting improves reasoning by encouraging explicit intermediate steps.",
        "incorrect": "This phrase triggers a specific behavior in how LLMs process complex problems.",
        "explanation": "Chain-of-thought (CoT) prompting asks the model to show its reasoning. For math, logic, or multi-step problems, this significantly improves accuracy. The model is less likely to skip steps or make reasoning errors when it 'thinks aloud.' The phrase 'Let's think step by step' or 'Think through this carefully' triggers this behavior."
      }
    },
    {
      "id": "llm-prompting-003",
      "topic": "llm-prompting",
      "difficulty": "hard",
      "stem": "What's a 'system prompt' and why is it important?",
      "options": [
        { "id": "A", "text": "A prompt that only system administrators can see" },
        { "id": "B", "text": "Instructions that set the model's persona, constraints, and behavior across the conversation" },
        { "id": "C", "text": "Error messages from the API" },
        { "id": "D", "text": "The default response when no user input is provided" }
      ],
      "correct": "B",
      "feedback": {
        "correct": "Correct! System prompts configure the model's behavior, persona, and constraints for the entire conversation.",
        "incorrect": "The system prompt is separate from user messages and has special significance.",
        "explanation": "System prompts set the context: 'You are a helpful coding assistant. Never provide harmful code. Always explain your reasoning.' They persist across the conversation and have higher weight than user messages. Good system prompts define: persona, capabilities, limitations, output format, and safety constraints. They're crucial for building reliable AI applications."
      }
    },
    {
      "id": "llm-tools-001",
      "topic": "llm-tools",
      "difficulty": "medium",
      "stem": "What is 'function calling' (tool use) in LLM APIs?",
      "options": [
        { "id": "A", "text": "The LLM executing JavaScript functions" },
        { "id": "B", "text": "The LLM generating structured output that indicates which function to call with what arguments" },
        { "id": "C", "text": "Calling the LLM API from a function" },
        { "id": "D", "text": "Using callbacks for async LLM responses" }
      ],
      "correct": "B",
      "feedback": {
        "correct": "Correct! Function calling lets the LLM request that you execute functions and return results.",
        "incorrect": "The LLM doesn't execute functions—it requests that you do.",
        "explanation": "Function calling enables LLMs to interact with external systems. You define available functions (name, description, parameters). The model outputs structured JSON indicating which function to call. YOU execute the function and return results to the model. This enables: API calls, database queries, calculations, web searches—anything you implement."
      }
    },
    {
      "id": "llm-tools-002",
      "topic": "llm-tools",
      "difficulty": "hard",
      "stem": "What is RAG (Retrieval-Augmented Generation)?",
      "options": [
        { "id": "A", "text": "A technique for generating random responses" },
        { "id": "B", "text": "Retrieving relevant documents and including them in the prompt to ground responses in specific knowledge" },
        { "id": "C", "text": "A model architecture that replaces transformers" },
        { "id": "D", "text": "Automatically generating training data" }
      ],
      "correct": "B",
      "feedback": {
        "correct": "Correct! RAG combines retrieval systems with generation to provide accurate, sourced responses.",
        "incorrect": "RAG addresses a key limitation of LLMs: their knowledge cutoff date.",
        "explanation": "RAG solves the 'knowledge cutoff' problem. Instead of relying only on training data: 1) User asks a question, 2) System retrieves relevant documents (from vector DB, search, etc.), 3) Retrieved context is added to the prompt, 4) LLM generates a response grounded in that context. This enables: up-to-date info, private data access, and cited sources."
      }
    },
    {
      "id": "llm-tools-003",
      "topic": "llm-tools",
      "difficulty": "hard",
      "stem": "What is the Model Context Protocol (MCP)?",
      "options": [
        { "id": "A", "text": "A compression format for reducing model size" },
        { "id": "B", "text": "An open protocol for connecting LLMs to external data sources and tools" },
        { "id": "C", "text": "A security protocol for encrypting prompts" },
        { "id": "D", "text": "A benchmark for evaluating model performance" }
      ],
      "correct": "B",
      "feedback": {
        "correct": "Correct! MCP standardizes how AI applications connect to data sources, tools, and services.",
        "incorrect": "MCP is about connecting LLMs to external capabilities.",
        "explanation": "MCP (Model Context Protocol) is an open standard for connecting AI assistants to external systems. It defines how to expose: resources (data the model can read), tools (functions the model can call), and prompts (reusable templates). MCP servers provide these capabilities; MCP clients (like Claude) consume them. It's like an API standard for AI integrations."
      }
    }
  ]
}
